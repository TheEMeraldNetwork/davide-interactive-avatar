<!DOCTYPE html>
<html>
<head>
    <title>Davide Consiglio - Interactive Avatar Profile (Voice Enhanced)</title>
    <script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
    <style>
        :root {
            --primary-color: #e0e0e0;
            --secondary-color: #a0a0a0;
            --accent-color: #404040;
            --text-color: #2c3e50;
            --border-color: #404040;
            --hover-color: #f8f9fa;
            --dark-bg: #1a1a1a;
            --header-gradient: linear-gradient(135deg, #000000, #1a1a1a);
            --modal-bg: rgba(0, 0, 0, 0.95);
            --modal-content-bg: #1a1a1a;
            --link-color: #4a90e2;
            --link-hover: #357abd;
        }
        
        body { 
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background-color: #f5f6fa;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #000 0%, #1a1a1a 100%);
            padding: 25px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 50%, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0) 70%);
            pointer-events: none;
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-controls {
            display: flex;
            align-items: center;
        }
        
        .header-title {
            font-family: "Porsche Next", "Segoe UI", Arial, sans-serif;
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 1px;
            color: #fff;
            margin: 0;
        }
        
        .header-subtitle {
            font-size: 16px;
            color: rgba(255,255,255,0.8);
            font-weight: 300;
            margin-top: 5px;
        }
        
        .refresh-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px;
            color: #fff;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .refresh-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        /* Voice Control Styles */
        .voice-control {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 16px;
            color: #fff;
            font-size: 12px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .voice-control:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .voice-control.listening {
            background: rgba(244, 67, 54, 0.2);
            border-color: rgba(244, 67, 54, 0.5);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .voice-status {
            font-size: 10px;
            font-weight: 500;
        }
        
        .voice-transcript {
            position: fixed;
            bottom: 20px;
            right: 20px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 10000;
        }
        
        .voice-transcript.show {
            transform: translateX(0);
        }
        
        .voice-transcript .interim {
            color: #ccc;
            font-style: italic;
        }
        
        .voice-transcript .final {
            color: #fff;
            font-weight: 500;
        }
        
        .card {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 40px;
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 25px 30px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        
        .card-title {
            font-family: "Porsche Next", "Segoe UI", Arial, sans-serif;
            font-size: 24px;
            font-weight: 300;
            color: #000;
            margin: 0;
            letter-spacing: 0.5px;
        }
        
        .card-content {
            padding: 30px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 20px 0;
        }
        
        .info-item {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #000;
        }
        
        .info-label {
            font-weight: 600;
            color: #000;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .info-value {
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .timeline {
            position: relative;
            padding: 20px 0;
        }
        
        .timeline::before {
            content: '';
            position: absolute;
            left: 30px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #000;
        }
        
        .timeline-item {
            position: relative;
            padding: 20px 0 20px 70px;
            margin-bottom: 20px;
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            left: 22px;
            top: 25px;
            width: 16px;
            height: 16px;
            background: #000;
            border-radius: 50%;
            border: 3px solid #fff;
            box-shadow: 0 0 0 3px #000;
        }
        
        .timeline-date {
            font-weight: 600;
            color: #000;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .timeline-title {
            font-size: 18px;
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 8px;
        }
        
        .timeline-desc {
            color: #666;
            line-height: 1.5;
        }
        
        .skill-tag {
            display: inline-block;
            background: #000;
            color: #fff;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin: 4px 4px 4px 0;
            font-weight: 500;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            text-align: center;
            padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
        }
        
        .stat-number {
            font-size: 32px;
            font-weight: 300;
            color: #000;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        @media (max-width: 768px) {
            .header-content {
                padding: 0 20px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .header-title {
                font-size: 20px;
            }
            
            .card {
                margin: 20px 10px;
                border-radius: 8px;
            }
            
            .card-header, .card-content {
                padding: 20px;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .timeline-item {
                padding-left: 50px;
            }
            
            .timeline::before {
                left: 20px;
            }
            
            .timeline-item::before {
                left: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Journal Debug Panel -->
    <div id="journal-debug" style="
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 10px;
        max-width: 300px;
        z-index: 9999;
        backdrop-filter: blur(10px);
    ">
        <div style="color: #666;">Journal vuoto</div>
    </div>
    <div class="header">
        <div class="header-content">
            <div style="display: flex; align-items: center; gap: 20px;">
                <img src="logo Emerald-03.png" alt="Emerald Logo" style="width: 60px; height: 60px; object-fit: contain;">
                <div>
                    <h1 class="header-title">Davide Consiglio</h1>
                    <div class="header-subtitle">Country Data Officer ‚Ä¢ Data & AI Strategy Expert</div>
                </div>
            </div>
            <div class="header-controls">
                <div style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 8px 16px; color: #fff; font-size: 12px; border-radius: 20px; backdrop-filter: blur(5px);">
                    ü§ñ Avatar attivo
                </div>
                        <div id="voiceControl" class="voice-control">
            <span id="voiceIcon">Mic</span>
            <span id="voiceStatus" class="voice-status">Voice Input</span>
        </div>
                <button class="refresh-btn" onclick="window.location.reload()">
                    <span>Refresh</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Voice Transcript Display -->
    <div id="voiceTranscript" class="voice-transcript">
        <div id="transcriptText">In attesa di input vocale...</div>
    </div>
    
    <div class="container">
        <!-- Welcome Banner -->
        <div class="card">
            <div class="card-content" style="text-align: center; padding: 50px 30px;">
                <h1 style="font-size: 48px; font-weight: 300; color: #000; margin: 0 0 20px 0; letter-spacing: 1px;">
                    Benvenuti all'offsite CDO 2025 - Grezzana
                </h1>
                <div style="width: 100px; height: 4px; background: linear-gradient(135deg, #000 0%, #333 100%); margin: 0 auto;"></div>
                <p style="margin-top: 20px; color: #666; font-size: 16px;">
                    üé§ <strong>Novit√†:</strong> Prova il riconoscimento vocale migliorato! Clicca il microfono in alto.
                </p>
            </div>
        </div>

        <!-- Personal Information -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Personal Information</h2>
            </div>
            <div class="card-content">
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Current Role</div>
                        <div class="info-value">Country Data Officer at Generali Italia</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Location</div>
                        <div class="info-value">Milan, Lombardy, Italy</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Education</div>
                        <div class="info-value">Masters Degree in Economics</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Daughter</div>
                        <div class="info-value">Vittoria Consiglio (13 years old)</div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">17+</div>
                        <div class="stat-label">Years Experience</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">10</div>
                        <div class="stat-label">Years at BCG</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">5+</div>
                        <div class="stat-label">Years at Generali</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Professional Experience -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Professional Timeline</h2>
            </div>
            <div class="card-content">
                <div class="timeline">
                    <div class="timeline-item">
                        <div class="timeline-date">September 2022 - Present</div>
                        <div class="timeline-title">Country Data Officer</div>
                        <div class="timeline-desc">Generali Italia ‚Ä¢ Leading data and AI strategy initiatives across the Italian operations</div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-date">October 2017 - September 2022</div>
                        <div class="timeline-title">Head of Advanced Analytics</div>
                        <div class="timeline-desc">Generali Italia ‚Ä¢ Built and led advanced analytics capabilities for insurance operations</div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-date">2007 - 2017</div>
                        <div class="timeline-title">Principal</div>
                        <div class="timeline-desc">Boston Consulting Group (BCG Gamma) ‚Ä¢ 10 years in management consulting and advanced analytics</div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-date">2004 - 2007</div>
                        <div class="timeline-title">Data Science Consultant</div>
                        <div class="timeline-desc">Value Lab ‚Ä¢ Early career in data science and quantitative analysis</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Core Expertise -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Core Expertise & Skills</h2>
            </div>
            <div class="card-content">
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 15px; color: #000;">Strategic & Leadership</h4>
                    <span class="skill-tag">Data & AI Strategy</span>
                    <span class="skill-tag">Strategic Planning</span>
                    <span class="skill-tag">Management Consulting</span>
                    <span class="skill-tag">Digital Transformation</span>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 15px; color: #000;">Technical & Analytics</h4>
                    <span class="skill-tag">Advanced Analytics</span>
                    <span class="skill-tag">Predictive Modeling</span>
                    <span class="skill-tag">Data Mining</span>
                    <span class="skill-tag">Statistics</span>
                    <span class="skill-tag">Econometrics</span>
                    <span class="skill-tag">Machine Learning</span>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 15px; color: #000;">Industry Focus</h4>
                    <span class="skill-tag">Financial Services</span>
                    <span class="skill-tag">Insurance</span>
                    <span class="skill-tag">Risk Management</span>
                    <span class="skill-tag">Financial Modeling</span>
                </div>
            </div>
        </div>

        <!-- Family Information -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Family</h2>
            </div>
            <div class="card-content">
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Parents</div>
                        <div class="info-value">
                            Silvana D'Alessandro (born Chieti, Feb 18, 1954)<br>
                            Salvatore Consiglio (born Siracusa, Jan 27, 1952)
                        </div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Sister</div>
                        <div class="info-value">Sara Consiglio (born Chieti, Feb 6, 1985)</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Brother-in-law</div>
                        <div class="info-value">Luigi Bocola (born Chieti, Mar 9, 1983)</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Niece</div>
                        <div class="info-value">Nina Bocola (born Palo Alto, May 25, 2020)</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Avatar Instructions -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Interactive Avatar Guidelines</h2>
            </div>
            <div class="card-content">
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Communication Style</div>
                        <div class="info-value">Professional yet approachable, confident, analytical mindset with strategic thinking</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Response Limits</div>
                        <div class="info-value">Maximum 3 sentences, 50 words per sentence</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Focus Areas</div>
                        <div class="info-value">Data strategy, AI implementation, financial services transformation, leadership insights</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Conversation Scope</div>
                        <div class="info-value">Professional experience, industry insights, data/AI expertise, personal background when relevant</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Voice Recognition Script -->
    <script>
        class EnhancedVoiceInterface {
            constructor() {
                this.recognition = null;
                this.isListening = false;
                this.finalTranscript = '';
                this.interimTranscript = '';
                this.lastSentText = ''; // Track last sent text to prevent duplicates
                
                // JOURNAL SYSTEM - track all questions
                this.questionJournal = [];
                this.currentQuestionId = 0;
                
                this.initializeElements();
                this.setupVoiceRecognition();
                this.setupEventListeners();
            }
            
            initializeElements() {
                this.voiceControl = document.getElementById('voiceControl');
                this.voiceIcon = document.getElementById('voiceIcon');
                this.voiceStatus = document.getElementById('voiceStatus');
                this.voiceTranscript = document.getElementById('voiceTranscript');
                this.transcriptText = document.getElementById('transcriptText');
            }
            
            setupVoiceRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'it-IT';
                    
                    this.recognition.onstart = () => {
                        this.isListening = true;
                        this.updateVoiceUI('listening');
                        this.showTranscript();
                        
                        // PULISCI cache quando inizia a parlare
                        this.clearClipboardCache();
                    };
                    
                    this.recognition.onresult = (event) => {
                        this.interimTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            
                            if (event.results[i].isFinal) {
                                this.finalTranscript += transcript + ' ';
                                this.sendToHeyGen(transcript.trim());
                            } else {
                                this.interimTranscript += transcript;
                            }
                        }
                        
                        this.updateTranscriptDisplay();
                    };
                    
                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        this.handleVoiceError(event.error);
                    };
                    
                    this.recognition.onend = () => {
                        this.isListening = false;
                        this.updateVoiceUI('idle');
                        
                        setTimeout(() => {
                            this.hideTranscript();
                        }, 3000);
                    };
                } else {
                    this.voiceStatus.textContent = 'Non supportato';
                    this.voiceControl.style.opacity = '0.5';
                }
            }
            
            setupEventListeners() {
                this.voiceControl.addEventListener('click', () => {
                    if (this.recognition) {
                        if (this.isListening) {
                            this.stopListening();
                        } else {
                            this.startListening();
                        }
                    }
                });
            }
            
            startListening() {
                if (!this.recognition || this.isListening) return;
                
                try {
                    this.finalTranscript = '';
                    this.interimTranscript = '';
                    this.recognition.start();
                } catch (error) {
                    console.error('Error starting voice recognition:', error);
                    this.handleVoiceError('start-failed');
                }
            }
            
            stopListening() {
                if (this.recognition && this.isListening) {
                    this.recognition.stop();
                }
            }
            
            updateVoiceUI(state) {
                switch(state) {
                    case 'listening':
                        this.voiceIcon.textContent = 'üî¥';
                        this.voiceStatus.textContent = 'In ascolto...';
                        this.voiceControl.classList.add('listening');
                        break;
                    case 'processing':
                        this.voiceIcon.textContent = '‚ö°';
                        this.voiceStatus.textContent = 'Elaborando...';
                        this.voiceControl.classList.remove('listening');
                        break;
                    case 'idle':
                    default:
                        this.voiceIcon.textContent = 'üé§';
                        this.voiceStatus.textContent = 'Voice Input';
                        this.voiceControl.classList.remove('listening');
                        break;
                }
            }
            
            updateTranscriptDisplay() {
                let html = '';
                
                if (this.finalTranscript) {
                    html += `<span class="final">${this.finalTranscript}</span>`;
                }
                
                if (this.interimTranscript) {
                    html += `<span class="interim">${this.interimTranscript}</span>`;
                }
                
                this.transcriptText.innerHTML = html || 'In attesa di input vocale...';
            }
            
            showTranscript() {
                this.voiceTranscript.classList.add('show');
            }
            
            hideTranscript() {
                this.voiceTranscript.classList.remove('show');
            }
            
            sendToHeyGen(text) {
                // Prevent sending the same text consecutively
                if (text === this.lastSentText) {
                    console.log('Duplicate text detected, skipping:', text);
                    return;
                }
                
                console.log('Voice input captured:', text);
                this.lastSentText = text;
                this.updateVoiceUI('processing');
                
                // JOURNAL WORKFLOW - dedicated system
                this.addToJournal(text);
                
                // Show user-friendly feedback
                this.showProcessingFeedback(text);
                
                // Start clipboard workflow
                this.startClipboardWorkflow();
                
                // Reset duplicate prevention after 30 seconds
                setTimeout(() => {
                    if (this.lastSentText === text) {
                        this.lastSentText = '';
                        console.log('Duplicate prevention reset');
                    }
                }, 30000);
                
                setTimeout(() => {
                    this.updateVoiceUI('idle');
                }, 4000);
            }
            
            // === JOURNAL WORKFLOW - DEDICATED SYSTEM ===
            addToJournal(text) {
                this.currentQuestionId++;
                
                const question = {
                    id: this.currentQuestionId,
                    text: text,
                    timestamp: new Date().toISOString(),
                    time: Date.now()
                };
                
                this.questionJournal.push(question);
                
                console.log('üìù Question added to journal:', {
                    id: question.id,
                    text: question.text,
                    time: new Date(question.time).toLocaleTimeString()
                });
                
                console.log('üìö Journal now contains', this.questionJournal.length, 'questions');
                
                // Update debug panel
                this.updateJournalDebug();
                
                // Keep only last 10 questions for memory management
                if (this.questionJournal.length > 10) {
                    this.questionJournal = this.questionJournal.slice(-10);
                }
            }
            
            getCurrentQuestion() {
                if (this.questionJournal.length === 0) return null;
                
                // Get the most recent question (latest timestamp)
                const latest = this.questionJournal.reduce((latest, current) => {
                    return current.time > latest.time ? current : latest;
                });
                
                console.log('üéØ Current question (most recent):', latest.text);
                return latest;
            }
            
            // === CLIPBOARD WORKFLOW - DEDICATED SYSTEM ===
            startClipboardWorkflow() {
                const currentQuestion = this.getCurrentQuestion();
                if (!currentQuestion) {
                    console.log('‚ùå No question in journal');
                    return;
                }
                
                console.log('üìã Starting clipboard workflow for question:', currentQuestion.id);
                
                // Simple and direct clipboard copy
                this.copyToClipboard(currentQuestion.text, currentQuestion.id);
                
                // Show guidance
                this.showAutomationGuidance(currentQuestion.text);
            }
            
            async copyToClipboard(text, questionId) {
                try {
                    console.log(`üìã Copying question ${questionId} to clipboard:`, text);
                    
                    // Simple, direct copy - no complex clearing
                    await navigator.clipboard.writeText(text);
                    
                    // Verify
                    const verification = await navigator.clipboard.readText();
                    
                    if (verification === text) {
                        console.log(`‚úÖ Question ${questionId} successfully copied to clipboard`);
                        
                        // Update status
                        setTimeout(() => {
                            const status = document.getElementById('clipboard-status');
                            if (status) {
                                status.textContent = `‚úÖ Question ${questionId} copied to clipboard!`;
                                status.style.color = '#10b981';
                            }
                        }, 500);
                    } else {
                        throw new Error('Clipboard verification failed');
                    }
                    
                } catch(e) {
                    console.log(`‚ùå Failed to copy question ${questionId}:`, e);
                    
                    const status = document.getElementById('clipboard-status');
                    if (status) {
                        status.textContent = 'Copy failed - click Copy Again';
                        status.style.color = '#f59e0b';
                    }
                }
            }
            
            // Copy Again function using journal system
            async copyAgainFromJournal(buttonElement) {
                const currentQuestion = this.getCurrentQuestion();
                if (!currentQuestion) {
                    buttonElement.innerHTML = 'No Question';
                    setTimeout(() => buttonElement.innerHTML = 'Copy Again', 1500);
                    return;
                }
                
                console.log(`üîÑ Copy Again requested for question ${currentQuestion.id}`);
                
                try {
                    buttonElement.innerHTML = 'Copying...';
                    
                    // Direct copy from journal - always fresh
                    await navigator.clipboard.writeText(currentQuestion.text);
                    
                    // Verify
                    const verification = await navigator.clipboard.readText();
                    if (verification === currentQuestion.text) {
                        console.log(`‚úÖ Question ${currentQuestion.id} copied successfully via Copy Again`);
                        buttonElement.innerHTML = `‚úì Q${currentQuestion.id} Copied`;
                        
                        // Update main status
                        const status = document.getElementById('clipboard-status');
                        if (status) {
                            status.textContent = `‚úÖ Question ${currentQuestion.id} ready to paste!`;
                            status.style.color = '#10b981';
                        }
                    } else {
                        throw new Error('Verification failed');
                    }
                    
                } catch(e) {
                    console.log(`‚ùå Copy Again failed:`, e);
                    buttonElement.innerHTML = 'Failed';
                    
                    const status = document.getElementById('clipboard-status');
                    if (status) {
                        status.textContent = 'Copy failed - please try again';
                        status.style.color = '#ef4444';
                    }
                }
                
                // Reset button text
                setTimeout(() => {
                    buttonElement.innerHTML = 'Copy Again';
                }, 2000);
            }
            
            // Update journal debug display
            updateJournalDebug() {
                const debugDiv = document.getElementById('journal-debug');
                if (!debugDiv) return;
                
                if (this.questionJournal.length === 0) {
                    debugDiv.innerHTML = '<div style="color: #666;">Journal vuoto</div>';
                    return;
                }
                
                const html = this.questionJournal
                    .slice(-3) // Show last 3 questions
                    .map(q => `
                        <div style="padding: 4px; border-left: 2px solid ${q.id === this.currentQuestionId ? '#10b981' : '#666'}; margin: 2px 0;">
                            <small style="color: #666;">Q${q.id} - ${new Date(q.time).toLocaleTimeString()}</small><br>
                            <span style="font-size: 11px;">${q.text}</span>
                        </div>
                    `)
                    .join('');
                    
                debugDiv.innerHTML = html;
            }
            
            // Legacy function - now replaced by journal workflow system
            startIntelligentInjection(text) {
                console.log('‚ö†Ô∏è Legacy function call - use journal workflow instead');
                // Redirect to new workflow
                this.startClipboardWorkflow();
            }
            
            // Legacy Python automation - replaced by simpler journal system
            tryPythonAutomation(text) {
                console.log('Legacy function - use journal workflow instead');
            }
            
            // Legacy clipboard automation - replaced by journal system
            trySystemClipboardAutomation(text) {
                console.log('Legacy function - use journal workflow instead');
            }
            
            // Legacy complex clipboard clearing - removed due to issues
            async clearAndCopyText(text) {
                console.log('Legacy function removed - causing clipboard issues');
                // Simple direct copy instead
                await navigator.clipboard.writeText(text);
                return true;
            }
            
            // Legacy autoCopyFresh - removed, was causing clipboard issues
            async autoCopyFresh(text) {
                console.log('Legacy function removed - was causing clipboard cache issues');
            }
            
            // Legacy clearClipboardCache - removed
            async clearClipboardCache() {
                console.log('Legacy cache clearing removed - was problematic');
            }
            
            showAutomationGuidance(text) {
                // Show a helpful popup with automation instructions
                const popup = document.createElement('div');
                popup.id = 'automation-guidance';
                popup.innerHTML = `
                    <div style="
                        position: fixed;
                        bottom: 100px;
                        right: 20px;
                        transform: none;
                        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
                        color: white;
                        padding: 20px;
                        border-radius: 12px;
                        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
                        z-index: 10001;
                        max-width: 320px;
                        text-align: center;
                        border: 2px solid rgba(255,255,255,0.2);
                    ">
                        <div style="font-size: 18px; margin-bottom: 12px; font-weight: bold;">
                            Auto Copy
                        </div>
                        <div style="
                            background: rgba(255,255,255,0.15);
                            padding: 15px;
                            border-radius: 12px;
                            margin-bottom: 20px;
                            font-style: italic;
                        ">
                            "${text}"
                        </div>
                        <div style="font-size: 14px; margin-bottom: 20px; opacity: 0.9;">
                            ‚úÖ Fresh text copied to clipboard!<br>
                            <strong>Click in HeyGen chat ‚Üí Press Cmd+V</strong><br>
                            <small style="opacity: 0.7;" id="clipboard-status">(Auto-refreshing clipboard...)</small>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button onclick="this.closest('#automation-guidance').remove()" style="
                                background: rgba(255,255,255,0.2);
                                color: white;
                                border: 2px solid rgba(255,255,255,0.3);
                                padding: 10px 20px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                            ">
                                Done
                            </button>
                            <button onclick="
                                // Use journal system for copy again
                                window.voiceInterface.copyAgainFromJournal(this);
                            " style="
                                background: rgba(255,255,255,0.3);
                                color: white;
                                border: 2px solid rgba(255,255,255,0.4);
                                padding: 10px 20px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                            ">
                                Copy Again
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                // Auto-remove after 15 seconds
                setTimeout(() => {
                    if (popup && popup.parentNode) {
                        popup.remove();
                    }
                }, 15000);
            }
            
            setupPasteDetection() {
                // Listen for paste events to detect when user might have pasted
                let pasteDetected = false;
                
                const pasteListener = (e) => {
                    if (!pasteDetected) {
                        pasteDetected = true;
                        console.log('Paste activity detected - user likely completed action');
                        this.showSuccessFeedback('Text pasted successfully!');
                        document.removeEventListener('paste', pasteListener);
                    }
                };
                
                document.addEventListener('paste', pasteListener);
                
                // Remove listener after 30 seconds
                setTimeout(() => {
                    document.removeEventListener('paste', pasteListener);
                }, 30000);
            }
            
            tryDirectInjection(text) {
                console.log('Attempting direct injection...');
                
                // Look for the most common HeyGen input patterns
                const commonSelectors = [
                    'input[type="text"]',
                    'textarea',
                    '[contenteditable="true"]'
                ];
                
                for (const selector of commonSelectors) {
                    const elements = document.querySelectorAll(selector);
                    
                    for (const element of elements) {
                        if (this.isVisibleAndInteractable(element)) {
                            console.log('Found potential input:', element);
                            
                            if (this.attemptFill(element, text)) {
                                console.log('Direct injection successful');
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            isVisibleAndInteractable(element) {
                if (!element || element.disabled || element.readOnly) return false;
                
                const rect = element.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return false;
                
                const style = window.getComputedStyle(element);
                if (style.display === 'none' || style.visibility === 'hidden') return false;
                
                return true;
            }
            
            attemptFill(element, text) {
                try {
                    // Focus the element
                    element.focus();
                    
                    // Clear existing content
                    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                        element.value = '';
                        element.value = text;
                    } else if (element.contentEditable === 'true') {
                        element.innerHTML = '';
                        element.innerHTML = text;
                    }
                    
                    // Trigger events
                    ['input', 'change', 'keydown', 'keyup'].forEach(eventType => {
                        const event = new Event(eventType, { bubbles: true });
                        element.dispatchEvent(event);
                    });
                    
                    // Try to find and click submit button
                    setTimeout(() => this.trySubmit(element), 200);
                    
                    return true;
                } catch (error) {
                    console.log('Fill attempt failed:', error);
                    return false;
                }
            }
            
            trySubmit(element) {
                // Look for submit buttons near the input
                const container = element.closest('form') || element.closest('div') || document;
                
                const submitSelectors = [
                    'button[type="submit"]',
                    'input[type="submit"]',
                    'button:not([type])',
                    '.send-button',
                    '.submit-button'
                ];
                
                for (const selector of submitSelectors) {
                    const button = container.querySelector(selector);
                    if (button && this.isVisibleAndInteractable(button)) {
                        console.log('Clicking submit button:', button);
                        button.click();
                        return;
                    }
                }
                
                // Try Enter key as fallback
                const enterEvent = new KeyboardEvent('keydown', {
                    key: 'Enter',
                    code: 'Enter',
                    keyCode: 13,
                    bubbles: true
                });
                element.dispatchEvent(enterEvent);
            }
            
            setupSmartRetry(text) {
                let attempts = 0;
                const maxAttempts = 6;
                
                const retry = setInterval(() => {
                    attempts++;
                    console.log(`Retry attempt ${attempts}/${maxAttempts}`);
                    
                    if (attempts >= maxAttempts) {
                        clearInterval(retry);
                        console.log('Max attempts reached, showing fallback');
                        this.showFailureFeedback(text);
                        return;
                    }
                    
                    const success = this.tryDirectInjection(text);
                    if (success) {
                        clearInterval(retry);
                        this.showSuccessFeedback(text);
                    }
                }, 1000);
            }
            
            setupContentObserver(text) {
                const observer = new MutationObserver((mutations) => {
                    let shouldRetry = false;
                    
                    mutations.forEach((mutation) => {
                        if (mutation.addedNodes.length > 0) {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === 1 && (
                                    node.querySelector('input') || 
                                    node.querySelector('textarea') ||
                                    node.tagName === 'INPUT' ||
                                    node.tagName === 'TEXTAREA'
                                )) {
                                    shouldRetry = true;
                                }
                            });
                        }
                    });
                    
                    if (shouldRetry) {
                        console.log('New input detected, retrying...');
                        setTimeout(() => this.tryDirectInjection(text), 500);
                    }
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
                
                // Stop observing after 10 seconds
                setTimeout(() => {
                    observer.disconnect();
                    console.log('Content observer stopped');
                }, 10000);
            }
            
              
              // Legacy functions removed - using new automation system
              
              showCapturedTextWithActions(text) {
                // Update transcript to show what will be sent with manual options
                this.transcriptText.innerHTML = `
                    <div style="color: #4CAF50; font-weight: bold; margin-bottom: 10px;">
                        ‚úÖ Testo riconosciuto:
                    </div>
                    <div style="color: #fff; font-size: 16px; line-height: 1.4; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; margin: 10px 0; user-select: all; cursor: text;">
                        "${text}"
                    </div>
                    <div style="display: flex; gap: 10px; margin: 15px 0;">
                        <button onclick="navigator.clipboard.writeText('${text.replace(/'/g, "\\'")}'); this.innerText='‚úÖ Copiato!'" 
                                style="background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            üìã Copia
                        </button>
                        <button onclick="document.getElementById('voiceTranscript').classList.remove('show')" 
                                style="background: #666; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            ‚úñ Chiudi
                        </button>
                    </div>
                    <div style="color: #FFD700; font-size: 11px; text-align: center;">
                        üîÑ Tentativo invio automatico in corso...<br>
                        Se non funziona, copia e incolla nell'avatar HeyGen
                    </div>
                `;
                this.voiceTranscript.classList.add('show');
                
                // Keep it visible longer for manual action if needed
                setTimeout(() => {
                    if (this.voiceTranscript.classList.contains('show')) {
                        this.updateTranscriptForManualAction(text);
                    }
                }, 3000);
            }
            
            updateTranscriptForManualAction(text) {
                this.transcriptText.innerHTML = `
                    <div style="color: #FF9800; font-weight: bold; margin-bottom: 10px;">
                        ‚ö†Ô∏è Invio manuale richiesto:
                    </div>
                    <div style="color: #fff; font-size: 16px; line-height: 1.4; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; margin: 10px 0; user-select: all; cursor: text;">
                        "${text}"
                    </div>
                    <div style="display: flex; gap: 10px; margin: 15px 0;">
                        <button onclick="navigator.clipboard.writeText('${text.replace(/'/g, "\\'")}'); this.innerText='‚úÖ Copiato!'" 
                                style="background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            üìã Copia testo
                        </button>
                        <button onclick="document.getElementById('voiceTranscript').classList.remove('show')" 
                                style="background: #666; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            ‚úñ Chiudi
                        </button>
                    </div>
                    <div style="color: #ccc; font-size: 11px; text-align: center;">
                        Incolla nel campo di testo dell'avatar HeyGen ‚Üí
                    </div>
                `;
            }
            
            tryIframeMessaging(text) {
                try {
                    const heygenIframe = document.querySelector('#heygen-streaming-container iframe');
                    if (heygenIframe) {
                        // Try multiple message formats that HeyGen might accept
                        const messages = [
                            { type: 'voice-input', text: text },
                            { type: 'text-input', content: text },
                            { type: 'chat-message', message: text },
                            { action: 'send-message', text: text }
                        ];
                        
                        messages.forEach(msg => {
                            heygenIframe.contentWindow.postMessage(msg, '*');
                        });
                        
                        console.log('üì§ Sent messages to HeyGen iframe');
                    }
                } catch (error) {
                    console.log('‚ùå Iframe messaging failed:', error);
                }
            }
            
            tryAdvancedAutoInput(text) {
                console.log('üîç Starting advanced search for HeyGen input...');
                
                // ULTRA-ADVANCED selectors including HeyGen-specific patterns
                const selectors = [
                    'input[type="text"]',
                    'input:not([type])',
                    'textarea',
                    '[contenteditable="true"]',
                    '[role="textbox"]',
                    '[data-testid*="input"]',
                    '[data-testid*="chat"]',
                    '[data-testid*="message"]',
                    '.chat-input',
                    '.message-input',
                    '.text-input',
                    '.input-field',
                    '[placeholder*="message"]',
                    '[placeholder*="chat"]',
                    '[placeholder*="type"]',
                    '[placeholder*="ask"]',
                    '[placeholder*="speak"]',
                    '[placeholder*="Enter"]',
                    '[placeholder*="Say"]',
                    // HeyGen specific selectors
                    '[class*="input"]',
                    '[class*="chat"]',
                    '[class*="message"]',
                    '[id*="input"]',
                    '[id*="chat"]',
                    '[id*="message"]'
                ];
                
                let success = false;
                let totalAttempts = 0;
                
                // Strategy A: Aggressive search in ALL possible containers
                const containers = [
                    document,
                    document.body,
                    ...Array.from(document.querySelectorAll('iframe')),
                    ...Array.from(document.querySelectorAll('[id*="heygen"]')),
                    ...Array.from(document.querySelectorAll('[class*="heygen"]')),
                    ...Array.from(document.querySelectorAll('div')).filter(div => 
                        div.innerHTML.includes('input') || div.innerHTML.includes('chat')
                    )
                ];
                
                console.log(`üîç Searching in ${containers.length} containers...`);
                
                for (const container of containers) {
                    if (success) break;
                    
                    // Try to access iframe content with multiple methods
                    let searchContainer = container;
                    if (container.tagName === 'IFRAME') {
                        try {
                            searchContainer = container.contentDocument || container.contentWindow?.document;
                            if (!searchContainer) continue;
                        } catch (e) {
                            console.log('‚ö†Ô∏è CORS blocked iframe:', e.message);
                            // Try postMessage approach for CORS-blocked iframes
                            this.tryIframePostMessage(container, text);
                            continue;
                        }
                    }
                    
                    for (const selector of selectors) {
                        try {
                            const inputs = searchContainer.querySelectorAll(selector);
                            console.log(`üéØ Found ${inputs.length} elements with selector: ${selector}`);
                            
                            for (const input of inputs) {
                                totalAttempts++;
                                console.log(`üß™ Testing input #${totalAttempts}:`, input);
                                
                                if (this.isValidHeyGenInput(input)) {
                                    console.log('‚úÖ Valid HeyGen input found!', input);
                                    success = this.performAdvancedFill(input, text);
                                    if (success) {
                                        console.log('üéâ Successfully injected via:', selector);
                                        return true;
                                    }
                                }
                            }
                        } catch (e) {
                            console.log('‚ö†Ô∏è Error with selector', selector, ':', e.message);
                        }
                    }
                }
                
                console.log(`üìä Total attempts: ${totalAttempts}`);
                
                // Strategy B: Try clicking everything that might reveal inputs
                if (!success) {
                    success = this.tryClickToRevealInput(text);
                }
                
                // Strategy C: Brute force - try to interact with any clickable element
                if (!success) {
                    success = this.tryBruteForceInteraction(text);
                }
                
                return success;
            }
            
            tryIframePostMessage(iframe, text) {
                console.log('üì§ Trying postMessage to iframe...');
                try {
                    iframe.contentWindow.postMessage({
                        type: 'VOICE_INPUT',
                        text: text,
                        action: 'FILL_INPUT'
                    }, '*');
                    
                    iframe.contentWindow.postMessage({
                        type: 'heygen-voice-input',
                        message: text
                    }, '*');
                    
                    console.log('üì§ PostMessage sent to iframe');
                } catch (e) {
                    console.log('‚ùå PostMessage failed:', e.message);
                }
            }
            
            tryBruteForceInteraction(text) {
                console.log('üí™ Starting brute force interaction...');
                
                // Find any element that might be related to chat/input
                const possibleElements = [
                    ...document.querySelectorAll('*')
                ].filter(el => {
                    const txt = (el.textContent || '').toLowerCase();
                    const classes = (el.className || '').toLowerCase();
                    const id = (el.id || '').toLowerCase();
                    
                    return (
                        txt.includes('chat') || txt.includes('message') || txt.includes('input') ||
                        classes.includes('chat') || classes.includes('message') || classes.includes('input') ||
                        id.includes('chat') || id.includes('message') || id.includes('input') ||
                        el.tagName === 'INPUT' || el.tagName === 'TEXTAREA'
                    );
                });
                
                console.log(`üí™ Found ${possibleElements.length} possible elements for brute force`);
                
                for (const element of possibleElements.slice(0, 20)) { // Limit to first 20
                    try {
                        // Try clicking first
                        element.click();
                        element.focus();
                        
                        // Try filling if it's an input-like element
                        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.contentEditable === 'true') {
                            this.performAdvancedFill(element, text);
                        }
                        
                        // Wait a bit for dynamic content
                        setTimeout(() => {
                            const newInputs = document.querySelectorAll('input, textarea, [contenteditable="true"]');
                            for (const newInput of newInputs) {
                                if (this.isValidHeyGenInput(newInput)) {
                                    this.performAdvancedFill(newInput, text);
                                }
                            }
                        }, 200);
                        
                    } catch (e) {
                        // Ignore errors in brute force
                    }
                }
                
                return false; // Brute force is always last resort
            }
            
            isValidHeyGenInput(element) {
                if (!element) {
                    console.log('‚ùå Element is null/undefined');
                    return false;
                }
                
                if (element.disabled || element.readOnly) {
                    console.log('‚ùå Element is disabled or readonly:', element);
                    return false;
                }
                
                const style = window.getComputedStyle(element);
                if (style.display === 'none' || style.visibility === 'hidden') {
                    console.log('‚ùå Element is hidden:', element);
                    return false;
                }
                
                // Check if it's actually visible and interactable
                const rect = element.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) {
                    console.log('‚ùå Element has zero dimensions:', element, rect);
                    return false;
                }
                
                const placeholder = element.placeholder?.toLowerCase() || '';
                const className = element.className?.toLowerCase() || '';
                const id = element.id?.toLowerCase() || '';
                const ariaLabel = element.getAttribute('aria-label')?.toLowerCase() || '';
                const tagName = element.tagName?.toLowerCase() || '';
                
                console.log('üîç Analyzing element:', {
                    tagName,
                    placeholder,
                    className,
                    id,
                    ariaLabel,
                    element
                });
                
                // Look for HeyGen-specific indicators OR any input element
                const heygenIndicators = [
                    'message', 'chat', 'type', 'ask', 'speak', 'input', 'text',
                    'conversation', 'query', 'prompt', 'send', 'enter'
                ];
                
                const isInputElement = ['input', 'textarea'].includes(tagName) || 
                                     element.contentEditable === 'true';
                
                const hasIndicator = heygenIndicators.some(indicator => 
                    placeholder.includes(indicator) ||
                    className.includes(indicator) ||
                    id.includes(indicator) ||
                    ariaLabel.includes(indicator)
                );
                
                const result = isInputElement || hasIndicator;
                
                console.log(`üéØ Element validation result: ${result ? '‚úÖ VALID' : '‚ùå INVALID'}`);
                
                return result;
            }
            
            performAdvancedFill(input, text) {
                try {
                    // Focus the input first
                    input.focus();
                    
                    // Clear existing content
                    if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {
                        input.select();
                        input.value = '';
                    } else if (input.contentEditable === 'true') {
                        input.innerHTML = '';
                    }
                    
                    // Simulate realistic typing
                    this.simulateTyping(input, text);
                    
                    // Try multiple submission methods
                    setTimeout(() => this.tryMultipleSubmit(input), 500);
                    
                    return true;
                } catch (error) {
                    console.log('‚ùå Advanced fill failed:', error);
                    return false;
                }
            }
            
            simulateTyping(input, text) {
                // Method 1: Direct value setting with events
                if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {
                    input.value = text;
                } else if (input.contentEditable === 'true') {
                    input.innerHTML = text;
                    input.textContent = text;
                }
                
                // Fire comprehensive events
                const events = [
                    'focus', 'click', 'keydown', 'keypress', 'input', 
                    'keyup', 'change', 'blur'
                ];
                
                events.forEach((eventType, index) => {
                    setTimeout(() => {
                        const event = new Event(eventType, { 
                            bubbles: true, 
                            cancelable: true 
                        });
                        
                        if (eventType.includes('key')) {
                            Object.defineProperty(event, 'key', { value: 'Enter' });
                            Object.defineProperty(event, 'keyCode', { value: 13 });
                            Object.defineProperty(event, 'which', { value: 13 });
                        }
                        
                        input.dispatchEvent(event);
                    }, index * 50);
                });
                
                // Method 2: Character-by-character simulation
                setTimeout(() => {
                    for (let i = 0; i < text.length; i++) {
                        setTimeout(() => {
                            const char = text[i];
                            const keyEvent = new KeyboardEvent('keypress', {
                                key: char,
                                code: `Key${char.toUpperCase()}`,
                                charCode: char.charCodeAt(0),
                                keyCode: char.charCodeAt(0),
                                which: char.charCodeAt(0),
                                bubbles: true
                            });
                            input.dispatchEvent(keyEvent);
                        }, i * 20);
                    }
                }, 100);
            }
            
            tryMultipleSubmit(input) {
                // Method 1: Find submit buttons
                const submitSelectors = [
                    'button[type="submit"]',
                    'input[type="submit"]',
                    'button:contains("Send")',
                    'button:contains("Invia")',
                    'button:contains("Ask")',
                    'button:contains("Chat")',
                    '.send-button',
                    '.submit-button',
                    '.chat-submit',
                    '[aria-label*="send"]',
                    '[aria-label*="submit"]',
                    '[title*="send"]',
                    '[title*="submit"]'
                ];
                
                const container = input.closest('form') || input.closest('div') || document;
                
                for (const selector of submitSelectors) {
                    const buttons = container.querySelectorAll(selector.replace(':contains', '[*='));
                    for (const button of buttons) {
                        if (button && !button.disabled && button.offsetParent !== null) {
                            setTimeout(() => {
                                button.click();
                                console.log('üöÄ Clicked submit button');
                            }, 100);
                            return;
                        }
                    }
                }
                
                // Method 2: Enter key simulation
                setTimeout(() => {
                    const enterEvent = new KeyboardEvent('keydown', {
                        key: 'Enter',
                        code: 'Enter',
                        keyCode: 13,
                        which: 13,
                        bubbles: true
                    });
                    input.dispatchEvent(enterEvent);
                }, 200);
                
                // Method 3: Form submission
                const form = input.closest('form');
                if (form) {
                    setTimeout(() => {
                        form.submit();
                    }, 300);
                }
            }
            
            tryClickToRevealInput(text) {
                // Look for buttons that might reveal chat interface
                const clickableSelectors = [
                    'button:contains("Chat")',
                    'button:contains("Ask")',
                    'button:contains("Message")',
                    '.chat-button',
                    '.start-chat',
                    '[aria-label*="chat"]',
                    '[aria-label*="message"]'
                ];
                
                for (const selector of clickableSelectors) {
                    const elements = document.querySelectorAll(selector.replace(':contains', '[*='));
                    for (const element of elements) {
                        if (element && element.offsetParent !== null) {
                            element.click();
                            console.log('üîò Clicked to reveal input:', selector);
                            
                            // Wait and try input again
                            setTimeout(() => this.tryAdvancedAutoInput(text), 1000);
                            break;
                        }
                    }
                }
            }
            
            fillInput(input, text) {
                // Set the value
                if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {
                    input.value = text;
                } else if (input.contentEditable === 'true') {
                    input.innerText = text;
                }
                
                // Trigger events to notify the application
                const events = ['input', 'change', 'keyup', 'blur'];
                events.forEach(eventType => {
                    const event = new Event(eventType, { bubbles: true });
                    input.dispatchEvent(event);
                });
                
                // Try to find and click send button
                setTimeout(() => {
                    this.tryClickSendButton(input);
                }, 100);
            }
            
            tryClickSendButton(input) {
                const sendSelectors = [
                    'button[type="submit"]',
                    'button:contains("Send")',
                    'button:contains("Invia")',
                    '.send-button',
                    '.submit-button',
                    '[title*="send"]',
                    '[aria-label*="send"]'
                ];
                
                // Look for send button near the input
                const parent = input.closest('form') || input.parentElement;
                if (parent) {
                    sendSelectors.forEach(selector => {
                        const button = parent.querySelector(selector.replace(':contains', '[*='));
                        if (button) {
                            button.click();
                            console.log('üöÄ Clicked send button');
                        }
                    });
                }
            }
            
            showProcessingFeedback(text) {
                this.showSimplePopup(text, 'processing', 'Processing voice input...');
            }
            
            showSuccessFeedback(text) {
                this.showSimplePopup(text, 'success', 'Message sent successfully!');
            }
            
            showFailureFeedback(text) {
                // Use the new automation guidance instead of old popup
                this.showAutomationGuidance(text);
            }
            
            showSimplePopup(text, type, message) {
                // Simple popup for processing and success states
                const existingPopup = document.getElementById('voice-text-popup');
                if (existingPopup) {
                    existingPopup.remove();
                }
                
                const colors = {
                    processing: 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%)',
                    success: 'linear-gradient(135deg, #10b981 0%, #059669 100%)'
                };
                
                const popup = document.createElement('div');
                popup.id = 'voice-text-popup';
                popup.innerHTML = `
                    <div style="
                        position: fixed;
                        bottom: 90px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: ${colors[type]};
                        color: white;
                        padding: 20px 30px;
                        border-radius: 15px;
                        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                        z-index: 10000;
                        text-align: center;
                        font-weight: 500;
                        transition: all 0.3s ease;
                    ">
                        ${message}
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                // Auto-remove
                setTimeout(() => {
                    if (popup && popup.parentNode) {
                        popup.style.opacity = '0';
                        setTimeout(() => popup.remove(), 300);
                    }
                }, type === 'processing' ? 3000 : 2000);
            }
            
            handleVoiceError(error) {
                let errorMessage = 'Errore vocale';
                
                switch(error) {
                    case 'not-allowed':
                        errorMessage = 'Permessi negati';
                        break;
                    case 'no-speech':
                        errorMessage = 'Nessun audio';
                        break;
                    case 'audio-capture':
                        errorMessage = 'Errore microfono';
                        break;
                    case 'network':
                        errorMessage = 'Errore rete';
                        break;
                    default:
                        errorMessage = 'Errore sconosciuto';
                }
                
                this.voiceStatus.textContent = errorMessage;
                this.updateVoiceUI('idle');
                
                setTimeout(() => {
                    this.voiceStatus.textContent = 'Clicca per parlare';
                }, 3000);
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new EnhancedVoiceInterface();
        });
    </script>

    <!-- HeyGen Avatar Embed Script -->
    <script>!function(window){const host="https://labs.heygen.com",url=host+"/guest/streaming-embed?share=eyJxdWFsaXR5IjoiaGlnaCIsImF2YXRhck5hbWUiOiIwMDk0OGZmZDMzMzQ0OTU0YjE0OWE1Zjlk%0D%0AZTJkNDVmMyIsInByZXZpZXdJbWciOiJodHRwczovL2ZpbGVzMi5oZXlnZW4uYWkvYXZhdGFyL3Yz%0D%0ALzAwOTQ4ZmZkMzMzNDQ5NTRiMTQ5YTVmOWRlMmQ0NWYzL2Z1bGwvMi4yL3ByZXZpZXdfdGFyZ2V0%0D%0ALndlYnAiLCJuZWVkUmVtb3ZlQmFja2dyb3VuZCI6ZmFsc2UsImtub3dsZWRnZUJhc2VJZCI6IjE0%0D%0AOGQ4MTM1YmVmNzRlZmE4OTE4NzJlOTZlNmYzZGQ0IiwidXNlcm5hbWUiOiJkN2ZmZWEwNDRmZjc0%0D%0AYTBiYWExOGFkMWI0N2ViZDNmYSJ9&inIFrame=1",clientWidth=document.body.clientWidth,wrapDiv=document.createElement("div");wrapDiv.id="heygen-streaming-embed";const container=document.createElement("div");container.id="heygen-streaming-container";const stylesheet=document.createElement("style");stylesheet.innerHTML=`\n  #heygen-streaming-embed {\n    z-index: 9999;\n    position: fixed;\n    right: 40px;\n    top: 200px;\n    width: 200px;\n    height: 200px;\n    border-radius: 50%;\n    border: 2px solid #fff;\n    box-shadow: 0px 8px 24px 0px rgba(0, 0, 0, 0.12);\n    transition: all linear 0.1s;\n    overflow: hidden;\n\n    opacity: 0;\n    visibility: hidden;\n  }\n  #heygen-streaming-embed.show {\n    opacity: 1;\n    visibility: visible;\n  }\n  #heygen-streaming-embed.expand {\n    ${clientWidth<540?"height: 266px; width: 96%; left: 50%; transform: translateX(-50%);":"height: 366px; width: calc(366px * 16 / 9);"}\n    border: 0;\n    border-radius: 8px;\n  }\n  #heygen-streaming-container {\n    width: 100%;\n    height: 100%;\n  }\n  #heygen-streaming-container iframe {\n    width: 100%;\n    height: 100%;\n    border: 0;\n  }\n  `;const iframe=document.createElement("iframe");iframe.allowFullscreen=!1,iframe.title="Streaming Embed",iframe.role="dialog",iframe.allow="microphone",iframe.src=url;let visible=!1,initial=!1;window.addEventListener("message",(e=>{e.origin===host&&e.data&&e.data.type&&"streaming-embed"===e.data.type&&("init"===e.data.action?(initial=!0,wrapDiv.classList.toggle("show",initial)):"show"===e.data.action?(visible=!0,wrapDiv.classList.toggle("expand",visible)):"hide"===e.data.action&&(visible=!1,wrapDiv.classList.toggle("expand",visible)))})),container.appendChild(iframe),wrapDiv.appendChild(stylesheet),wrapDiv.appendChild(container),document.body.appendChild(wrapDiv)}(globalThis);</script>

</body>
</html>